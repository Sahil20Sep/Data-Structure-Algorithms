        (Take card to make max score from front and back)

class Solution {
public:
    int maxScore(vector<int>& arr, int k) {
        int n = arr.size();
        int lsum = 0, rsum = 0;
        for(int i = 0; i < k; i++){
            lsum += arr[i];
        }
        if(n == k){
            return lsum;
        }
        int j = n - 1, tsum = lsum;
        for(int i = k - 1; i >= 0; i--){
            lsum -= arr[i];
            rsum += arr[j--];
            if(lsum + rsum > tsum){
                tsum = lsum + rsum;
            }
        }
        return tsum;
    }
};

-----------------------------------------------------------------------------------------

                (longest substring without reapeing char)

---------brute force 

generate all substring by 2 for loop and check condtion and take max len

------------better - create map for char and freq.

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int l = 0, r = 0, n = s.size(), len = 0;
        vector<int> hash(256, 0);
        while(r < n){
            hash[s[r]]++;
            while(hash[s[r]] > 1){
                hash[s[l++]]--;
            }
            len = max(len, r - l + 1);
            r++;
        }
        return len;
    }
};

---------optimal - create map for char and index. O(N) and O(256) to access the array is take constant not logn.

cadbzabcd

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int l = 0, r = 0, n = s.size(), len = 0;
        vector<int> hash(256, -1);
        while(r < n){
            if(hash[s[r]] >= l){
                l = hash[s[r]] + 1;
            }
            hash[s[r]] = r;
            len = max(len, r - l + 1);
            r++;
        }
        return len;
    }
};

---------------------------------------------------------------------------------------------------

        (maximum consicutive 1 III)

-----------brute force - generate all substring and check the condition

-----------better - 

class Solution {
public:
    int longestOnes(vector<int>& arr, int k) {
        int l = 0, r = 0, n = arr.size(), temp = 0, len = 0;
        while(r < n){
            if(arr[r] == 0){
                temp++;
            }
            while(temp > k){
                if(arr[l] == 0){
                    temp--;
                }
                l++;
            }
            len = max(len, r - l + 1);
            r++;
        }
        return len;
    }
};

------------optimal

class Solution {
public:
    int longestOnes(vector<int>& arr, int k) {
        int l = 0, r = 0, n = arr.size(), temp = 0, len = 0;
        while(r < n){
            if(arr[r] == 0){
                temp++;
            }
            if(temp > k){
                if(arr[l] == 0){
                    temp--;
                }
                l++;
            }
            if(temp <= k){
                len = max(len, r - l + 1);
            }
            r++;
        }
        return len;
    }
};

-------------------------------------------------------------------------------------------

                (maximum fruit put into basket 2 type)

-----------brute force

generate all subarray and check

------------better O(2N) O(3)

int totalFruits(int n, vector<int> &arr) {
        int l = 0, r = 0, len = 0;
        map<int, int> hash;
        while (r < n){
            hash[arr[r]]++;
            while(hash.size() > 2){
                hash[arr[l]]--;
                if(hash[arr[l]] == 0){
                    hash.erase(arr[l]);
                }
                l++;
            }
            len = max(len, r - l + 1);
            r++;
        }
        return len;
}

---------optimal

int totalFruits(int n, vector<int> &arr) {
        int l = 0, r = 0, len = 0;
        map<int, int> hash;
        while (r < n){
            hash[arr[r]]++;
            if(hash.size() > 2){
                hash[arr[l]]--;
                if(hash[arr[l]] == 0){
                    hash.erase(arr[l]);
                }
                l++;
            }
            if(hash.size() <= 2){
                len = max(len, r - l + 1);
            }
            r++;
        }
        return len;
    }

--------------------------------------------------------------------------------------

        (longest substring with at most/exect k distinct character)

----------brute force

generate all substring and check

----------better

int longestKSubstr(string s, int k) {
        int l = 0, r = 0, n = s.size(), len = -1;
        map<int, int> hash;
        while(r < n){
            hash[s[r] - 'a']++;
            while(hash.size() > k){
                hash[s[l] - 'a']--;
                if(hash[s[l] - 'a'] == 0){
                    hash.erase(s[l] - 'a');
                }
                l++;
            }
            if(hash.size() == k){
                len = max(len, r - l + 1);
            }
            r++;
        }
        return len;
    }

----------optimal

int longestKSubstr(string s, int k) {
        int l = 0, r = 0, n = s.size(), len = -1;
        map<int, int> hash;
        while(r < n){
            hash[s[r] - 'a']++;
            if(hash.size() > k){
                hash[s[l] - 'a']--;
                if(hash[s[l] - 'a'] == 0){
                    hash.erase(s[l] - 'a');
                }
                l++;
            }
            if(hash.size() == k){
                len = max(len, r - l + 1);
            }
            r++;
        }
        return len;
    }

--------------------------------------------------------------------------------------

        (substring that has same character with at most k flip operation)

------brute

generate all substring and check condition

----------better

class Solution {
public:
    int characterReplacement(string s, int k) {
        vector<int> cnt(26, 0);
        int l = 0, r = 0, n = s.size(), len = 0, maxf = 0;
        while(r < n){
            maxf = max(maxf, ++cnt[s[r] - 'A']);
            while(r - l + 1 - maxf > k){
                cnt[s[l++] - 'A']--;
                maxf = 0;
                for(int i = 0; i < 26; i++){
                    maxf = max(maxf, cnt[i]);
                }
            }   
            len = max(len, r - l + 1);
            r++;
        }
        return len;
    }
};

------optimal

class Solution {
public:
    int characterReplacement(string s, int k) {
        vector<int> cnt(26, 0);
        int l = 0, r = 0, n = s.size(), len = 0, maxf = 0;
        while(r < n){
            maxf = max(maxf, ++cnt[s[r] - 'A']);
            if(r - l + 1 - maxf > k){
                cnt[s[l++] - 'A']--;
                maxf = 0;
                for(int i = 0; i < 26; i++){
                    maxf = max(maxf, cnt[i]);
                }
            } 
            if(r - l + 1 - maxf <= k){
                len = max(len, r - l + 1);
            }  
            r++;
        }
        return len;
    }
};

we can remove the inside for loop 0 --> 26 no need to update it because we have to find maximum.

class Solution {
public:
    int characterReplacement(string s, int k) {
        vector<int> cnt(26, 0);
        int l = 0, r = 0, n = s.size(), len = 0, maxf = 0;
        while(r < n){
            maxf = max(maxf, ++cnt[s[r] - 'A']);
            if(r - l + 1 - maxf > k){
                cnt[s[l++] - 'A']--;
            } 
            if(r - l + 1 - maxf <= k){
                len = max(len, r - l + 1);
            }  
            r++;
        }
        return len;
    }
};

-------------------------------------------------------------------------------------------------

        (count the binary subarray which is equal to goal)

------brute

generate all subarray and check

------better

class Solution {
public:
    int numSubarraysWithSum(vector<int>& arr, int k) {
        int n = arr.size();
        int sum = 0;
        int ans = 0;
        map<int, int> hash;
        hash[0] = 1;
        for(int i = 0; i < n; i++){
            sum += arr[i];
            if(hash[sum - k] > 0){
                ans += hash[sum - k];
            }
            hash[sum]++;
        }
        return ans;
    }
};

-------optimal

class Solution {
public:

    int func(vector<int> &arr, int k){
        if(k < 0){
            return 0;
        }
        int l = 0, r = 0, n = arr.size(), cnt = 0, sum = 0;
        while(r < n){
            sum += arr[r];
            while(sum > k){
                sum -= arr[l++];
            }
            cnt += (r - l + 1);
            r++;
        }
        return cnt;
    }

    int numSubarraysWithSum(vector<int>& arr, int k) {
        return func(arr, k) - func(arr, k - 1);
    }
};
                
---------------------------------------------------------------------------------------

        (count the subarray with k odd number)

-----optimal

class Solution {
public:

    int func(vector<int> &arr, int k){
        int n = arr.size(), l = 0, r = 0, cnt = 0, odd = 0;
        while(r < n){
            odd += (arr[r] & 1);
            while(odd > k){
                odd -= (arr[l++] & 1);
            }
            cnt += (r - l + 1);
            r++;
        }
        return cnt;
    }

    int numberOfSubarrays(vector<int>& arr, int k) {
        return func(arr, k) - func(arr, k - 1);
    }
};

-------------------------------------------------------------------------------------------------

