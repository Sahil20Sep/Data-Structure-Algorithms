        (Take card to make max score from front and back)

class Solution {
public:
    int maxScore(vector<int>& arr, int k) {
        int n = arr.size();
        int lsum = 0, rsum = 0;
        for(int i = 0; i < k; i++){
            lsum += arr[i];
        }
        if(n == k){
            return lsum;
        }
        int j = n - 1, tsum = lsum;
        for(int i = k - 1; i >= 0; i--){
            lsum -= arr[i];
            rsum += arr[j--];
            if(lsum + rsum > tsum){
                tsum = lsum + rsum;
            }
        }
        return tsum;
    }
};

-----------------------------------------------------------------------------------------

                (longest substring without reapeing char)

---------brute force 

generate all substring by 2 for loop and check condtion and take max len

------------better - create map for char and freq.

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int l = 0, r = 0, n = s.size(), len = 0;
        vector<int> hash(256, 0);
        while(r < n){
            hash[s[r]]++;
            while(hash[s[r]] > 1){
                hash[s[l++]]--;
            }
            len = max(len, r - l + 1);
            r++;
        }
        return len;
    }
};

---------optimal - create map for char and index. O(N) and O(256) to access the array is take constant not logn.

cadbzabcd

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int l = 0, r = 0, n = s.size(), len = 0;
        vector<int> hash(256, -1);
        while(r < n){
            if(hash[s[r]] >= l){
                l = hash[s[r]] + 1;
            }
            hash[s[r]] = r;
            len = max(len, r - l + 1);
            r++;
        }
        return len;
    }
};

---------------------------------------------------------------------------------------------------

        (maximum consicutive 1 III)

-----------brute force - generate all substring and check the condition

-----------better - 

class Solution {
public:
    int longestOnes(vector<int>& arr, int k) {
        int l = 0, r = 0, n = arr.size(), temp = 0, len = 0;
        while(r < n){
            if(arr[r] == 0){
                temp++;
            }
            while(temp > k){
                if(arr[l] == 0){
                    temp--;
                }
                l++;
            }
            len = max(len, r - l + 1);
            r++;
        }
        return len;
    }
};

------------optimal

class Solution {
public:
    int longestOnes(vector<int>& arr, int k) {
        int l = 0, r = 0, n = arr.size(), temp = 0, len = 0;
        while(r < n){
            if(arr[r] == 0){
                temp++;
            }
            if(temp > k){
                if(arr[l] == 0){
                    temp--;
                }
                l++;
            }
            if(temp <= k){
                len = max(len, r - l + 1);
            }
            r++;
        }
        return len;
    }
};

-------------------------------------------------------------------------------------------

                (maximum fruit put into basket 2 type)

-----------brute force

generate all subarray and check

------------better O(2N) O(3)

int totalFruits(int n, vector<int> &arr) {
        int l = 0, r = 0, len = 0;
        map<int, int> hash;
        while (r < n){
            hash[arr[r]]++;
            while(hash.size() > 2){
                hash[arr[l]]--;
                if(hash[arr[l]] == 0){
                    hash.erase(arr[l]);
                }
                l++;
            }
            len = max(len, r - l + 1);
            r++;
        }
        return len;
}

---------optimal

int totalFruits(int n, vector<int> &arr) {
        int l = 0, r = 0, len = 0;
        map<int, int> hash;
        while (r < n){
            hash[arr[r]]++;
            if(hash.size() > 2){
                hash[arr[l]]--;
                if(hash[arr[l]] == 0){
                    hash.erase(arr[l]);
                }
                l++;
            }
            if(hash.size() <= 2){
                len = max(len, r - l + 1);
            }
            r++;
        }
        return len;
    }
