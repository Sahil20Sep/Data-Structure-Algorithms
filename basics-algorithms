                (sieve of erathonis)

class Solution
{
public:
    vector<int> sieveOfEratosthenes(int n)
    {
        vector<bool> mark(n + 1, true);
        
        mark[0] = mark[1] = false;
        
        vector<int> ans;
        
        for(int start = 2; start <= n; start++){ --> also put start * start
            
            if(mark[start] == true){
                
                ans.push_back(start);
                
                for(int ers = start + start; ers <= n; ers += start){ --> also put start * start
                    
                    mark[ers] = false;
                    
                }
            }
        }
        
        return ans;
    }
};

time complexity --> n (1/2 + 1/3 + 1/4 + 1/5 + ... + 1) --> O(NlogN);

but when i use mark[start] = true --> n (1/2 + 1/3 + 1/7 + 1/ 11 ++ ...) --> O(Nlog(Log(N)))

--------------------------------------------------------------------------------------------------------------

    armstrong number

digit cubes sum == n

extract the digit from and number and make cubes sums

---------------------------------------------------------------------------------------------------------------

    print all divisor

brute --

for 1 -> n and check n % i == 0

---better

for 1 -> i * i <= n and check n % i == 0 (i) if(n/i != i) (n/i)

-------------------------------------------------------------------------------------------------------------------

    prime number check

same as above if cnt == 2 then it's prime number.

-----------------------------------------------------------------------------

GCD

---brute force 

tell hime above solution 

store divisonn of a
store division of b

then compare match + greatest --> gcd

-----better

for i = 1 -> min(a, b)

  run above alog
  gcd = largeest number

run the reverse loop --> good better complexity but still worse case is 

------euilidium algo to find gcd

gcd(a, b) = gcd(a - b, b)

52, 10 --> 42, 10 --> 32, 10 --> ... --> 2, 10

gcd(a, b = gcd(a % b, b);

one of them is zero other is gcd

while a > 0 && b > 0
  a > b a = a % b
  b > a b = b % a

a == 0 return b
b == 0 return a

complexity logfi (min(a, b))

base is changing if it is constant thenw e can write 10, 2 as a base.
