----------------------------------------------------------------------------

    (exxtrack the digit and coutn the digit)

while(n > 0)
n%10  
store.push_back(n%10);
n/10
cnt++;

-------------------------------------------------------------------------------

      reverse a number

low = 0, high = n - 1

temp = arr[low]
arr[low] = arr[high]
arr[high] = temp

-----------------------------------------------------------------------------

palindrome check

low = 0 high n - 1
while Low < high
arr[low] == arr[high] 

else return false

--------------------------------------------------------------------------------------------------------------

    armstrong number

digit cubes sum == n

extract the digit from and number and make cubes sums

---------------------------------------------------------------------------------------------------------------

    print all divisor

brute --

for 1 -> n and check n % i == 0

---better

for 1 -> i * i <= n and check n % i == 0 (i) if(n/i != i) (n/i)

-------------------------------------------------------------------------------------------------------------------

    prime number check

same as above if cnt == 2 then it's prime number.

-----------------------------------------------------------------------------

GCD

---brute force 

tell hime above solution 

store divisonn of a
store division of b

then compare match + greatest --> gcd

-----better

for i = 1 -> min(a, b)

  run above alog
  gcd = largeest number

run the reverse loop --> good better complexity but still worse case is 

------euilidium algo to find gcd

gcd(a, b) = gcd(a - b, b)

52, 10 --> 42, 10 --> 32, 10 --> ... --> 2, 10

gcd(a, b = gcd(a % b, b);

one of them is zero other is gcd

while a > 0 && b > 0
  a > b a = a % b
  b > a b = b % a

a == 0 return b
b == 0 return a

complexity logfi (min(a, b))

base is changing if it is constant then e can write 10, 2 as a base.

----------------------------------------------------------------------------------

  give prime number in the range of 1 to N

---brute 

2 -> N

  Check(i) // is prime number sqrt(N) approch

n * sqrt(N) --> tiime complexity

------------better

prime[n + 1, true]
prime[0] = false;
prime[1] = false;

for(2 -> N)

  if(prime[i] == true
    for(j = 2 * i; j <= n j += i prime[j] false

2 -> n 
  if true --> print

-----optima

for 2 -> i*i <= n
    inside loop
    for j = i * il j <= n; j+= i

N log(logN)

prime harmonic series
space N

---------------------------------------------------------------

    L to R -- count the number 

brute 
for 1 to query size
for L to R
  if(j is prime)
      cnt++;

Q * r-l +1 * sqrt(N)

---better

precomputeation of prime number N loglogN + q * r - l + 1
 
for 1 to q
  for l to r
    if(prime[j] == true) cnt++;

-----------opptimal - prefix sum

precompute the prime array and prefix array

for 1 to q
  l, r
  here handle some case 
  cnt += pref[r] - pre[l -1];

time N loglogN + N + Q
  
