-----------------------------------------------------------------------------------------

    (intro)

node, vertex

directed cyclic/acyclic ggraph
undirected cyclic/acuclic graph

indgree --> number of incoming edge
outdegree --> number of outgoint edge

for undirected graph sum of total indegree = 2 * #ofedges

1 2 3 4 is path
then edges exits between adjecent node and do not repeat the visted node in path.

edges also contain weight if not then consider as 1.

if there is at least one cycle in graph callled cyclic graph.

--------------------------------------------------------------------------------------------

      (representation)

matrix
mat[n +1][n + 1];
mat[i][j] = 1 // represent i and j are connected

not usefull take O(N^2)

adj list
vector<int> adj[n + 1];

take only O(2E) space --> for undirected graph
take only (E) space --> for directed graph

---- about wt

mat[i][j] = wt;

in list we store pair adj[u].push_back({v,wt}];

-------------------------------------------------------------------------------------

        (connected componets)

maintain visited array 

run loop for 1 to n and check !vis[n] --> run_traversal(i);

------------------------------------------------------------------------------------

        (bfs)

---run for directed and undirected both

class Solution {
  public:
    vector<int> bfsOfGraph(int n, vector<int> adj[]) {
        vector<int> visited(n, false);
        visited[0] = true;
        queue<int> Q;
        Q.push(0);
        vector<int> bfs;
        while(!Q.empty()){
            int node = Q.front();
            Q.pop();
            bfs.push_back(node);
            for(auto it : adj[node]){
                if(!visited[it]){
                    visited[it] = true;
                    Q.push(it);
                }
            }
        }
        return bfs;
    }
};

space is O(2N) time is for directed O(N +E) and for undirected O(N + 2E).

----------------------------------------------------------------------------------------

            (dfs striver)

class Solution {
  public:
  
    void dfs(int node, vector<int> &ans, vector<int> adj[], vector<int> &visited){
        visited[node] = true;
        ans.push_back(node);
        for(auto it : adj[node]){
            if(!visited[it]){
                dfs(it, ans, adj, visited);
            }
        }
    }
  
    vector<int> dfsOfGraph(int n, vector<int> adj[]) {
        vector<int> visited(n, false);
        vector<int> ans;
        dfs(0, ans, adj, visited);
        return ans;
    }
};

space complexity O(N) + O(N) + recursion stack space O(N) if queue graph.
time complexity O(N + 2E)

--------------------------------------------------------------------------------------

                    (Number of Provinces)
----
class Solution {
public:

    void dfs(int node, vector<int> adj[], vector<int> &visited){
        visited[node] = true;
        for(auto it : adj[node]){
            if(!visited[it]){
                dfs(it, adj, visited);
            }
        }
    }

    int findCircleNum(vector<vector<int>>& arr) {
        int n = arr.size();
        vector<int> adj[n + 1];
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(arr[i][j] && i != j){
                    adj[i + 1].push_back(j + 1);
                    adj[j + 1].push_back(i + 1);
                }
            }
        }
        int cc = 0;
        vector<int> visited(n + 1, false);
        for(int i = 1; i <= n; i++){
            if(!visited[i]){
                cc++;
                dfs(i, adj, visited);
            }
        }
        return cc;
    }
};

space O(N) recursion stack space and O(N) visited
time O(N) + O(v + 2e)

---------------------------------------------------------------------

            (cc in matrix)

---bfs

class Solution {
public:

    void bfs(int i, int j, queue<pair<int, int>> &Q, vector<vector<bool>> &visited, vector<vector<char>> &arr, vector<pair<int, int>> &movement){
        int n = arr.size(), m = arr[0].size();
        visited[i][j] = true;
        Q.push({i, j});
        while(Q.size()){
            auto f = Q.front();
            Q.pop();
            for(auto it : movement){
                int x = f.first + it.first;
                int y = f.second + it.second;
                if(x >= 0 && x < n && y >= 0 && y < m && !visited[x][y] && arr[x][y] == '1'){
                    Q.push({x, y});
                    visited[x][y] = true;
                }
            }
        }
    }

    int numIslands(vector<vector<char>>& arr) {
        int n = arr.size(), m = arr[0].size();
        queue<pair<int, int>> Q;
        vector<vector<bool>> visited(n, vector<bool> (m, false));
        vector<pair<int, int>> movement = {
            {-1, 0}, {1, 0}, {0, 1}, {0, -1}
        };
        int cc = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(!visited[i][j] && arr[i][j] == '1'){
                    cc++;
                    bfs(i, j, Q, visited, arr, movement);
                }
            }
        }
        return cc;
    }
};

space O(N2) -- visited + O(N2) --> queue if all are 1
time O(N2) + 9 * O(N2)

--------------------------------------------------------------------------

        (flood fill)

class Solution {
public:

    void bfs(int i, int j, queue<pair<int, int>> &Q, vector<vector<bool>> &visited, vector<vector<char>> &arr, vector<pair<int, int>> &movement){
        int n = arr.size(), m = arr[0].size();
        visited[i][j] = true;
        Q.push({i, j});
        while(Q.size()){
            auto f = Q.front();
            Q.pop();
            for(auto it : movement){
                int x = f.first + it.first;
                int y = f.second + it.second;
                if(x >= 0 && x < n && y >= 0 && y < m && !visited[x][y] && arr[x][y] == '1'){
                    Q.push({x, y});
                    visited[x][y] = true;
                }
            }
        }
    }

    int numIslands(vector<vector<char>>& arr) {
        int n = arr.size(), m = arr[0].size();
        queue<pair<int, int>> Q;
        vector<vector<bool>> visited(n, vector<bool> (m, false));
        vector<pair<int, int>> movement = {
            {-1, 0}, {1, 0}, {0, 1}, {0, -1}
        };
        int cc = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(!visited[i][j] && arr[i][j] == '1'){
                    cc++;
                    bfs(i, j, Q, visited, arr, movement);
                }
            }
        }
        return cc;
    }
};

time 4 * n * m
space n * m

---------------------------------------------------------------------------------------

            (orange rotting)

class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        vector<vector<int>> arr = grid;
        int n = arr.size(), m = arr[0].size();
        queue<pair<pair<int, int>, int>> Q;
        vector<vector<bool>> visited(n, vector<bool> (m, false));
        int one = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(arr[i][j] == 2){
                    Q.push({{i, j}, 0});
                    visited[i][j] = true;
                }else if(arr[i][j] == 1){
                    one++;
                }
            }
        }
        if(one == 0){
            return 0;
        }
        vector<pair<int, int>> movement = {
            {-1, 0}, {0, -1}, {1, 0}, {0, 1}
        };
        int second = 0;
        while(Q.size()){
            auto f = Q.front();
            Q.pop();
            int time = f.second;
            if(time > second) second = time;
            for(auto it : movement){
                int x = f.first.first + it.first;
                int y = f.first.second + it.second;
                if(x >= 0 && x < n && y >= 0 && y < m && !visited[x][y] && arr[x][y] == 1){
                    Q.push({{x, y}, time + 1});
                    one--;
                    visited[x][y] = true;
                }
            }
        }
        return one ? -1 : second;
    }
};

-----

class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        vector<vector<int>> arr = grid;
        int n = arr.size(), m = arr[0].size();
        queue<pair<int, int>> Q;
        vector<vector<bool>> visited(n, vector<bool> (m, false));
        int one = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(arr[i][j] == 2){
                    Q.push({i, j});
                    visited[i][j] = true;
                }else if(arr[i][j] == 1){
                    one++;
                }
            }
        }
        if(one == 0){
            return 0;
        }
        vector<pair<int, int>> movement = {
            {-1, 0}, {0, -1}, {1, 0}, {0, 1}
        };
        int second = 0;
        while(Q.size()){
            int len = Q.size();
            second++;
            while(len--){
                auto f = Q.front();
                Q.pop();
                for(auto it : movement){
                    int x = f.first + it.first;
                    int y = f.second + it.second;
                    if(x >= 0 && x < n && y >= 0 && y < m && !visited[x][y] && arr[x][y] == 1){
                        Q.push({x, y});
                        one--;
                        visited[x][y] = true;
                    }
                }
            }
        }
        return one ? -1 : second - 1;
    }
};

-----

class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        vector<vector<int>> arr = grid;
        int n = arr.size(), m = arr[0].size();
        queue<pair<pair<int, int>, int>> Q;
        int one = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(arr[i][j] == 2){
                    Q.push({{i, j}, 0});
                }else if(arr[i][j] == 1){
                    one++;
                }
            }
        }
        if(one == 0){
            return 0;
        }
        vector<pair<int, int>> movement = {
            {-1, 0}, {0, -1}, {1, 0}, {0, 1}
        };
        int second = 0;
        while(Q.size()){
            auto f = Q.front();
            Q.pop();
            int time = f.second;
            if(time > second) second = time;
            for(auto it : movement){
                int x = f.first.first + it.first;
                int y = f.first.second + it.second;
                if(x >= 0 && x < n && y >= 0 && y < m && arr[x][y] == 1){
                    Q.push({{x, y}, time + 1});
                    one--;
                    arr[x][y] = 2;
                }
            }
        }
        return one ? -1 : second;
    }
};

----------------------------------------------------------------------------------------------

                (detect cycle -bfs)

class Solution {
  public:
  
    bool bfs(int i, vector<int> adj[], vector<bool> &visited){
        queue<pair<int, int>> Q;
        Q.push({i, -1});
        visited[i] = true;
        while(Q.size()){
            auto f = Q.front();
            Q.pop();
            int node = f.first;
            int par = f.second;
            for(auto it : adj[node]){
                if(!visited[it]){
                    visited[it] = true;
                    Q.push({it, node});
                }else if(par != it){
                    return true;
                }
            }
        }
        return false;
    }
  
    bool isCycle(int n, vector<int> adj[]) {
        vector<bool> visited(n, false);
        for(int i = 0; i < n; i++){
            if(!visited[i]){
                if(bfs(i, adj, visited)){
                    return true;
                }
            }
        }        
        return false;
    }
};

time n + n * 2*e
space 2n

-------------dfs

class Solution {
  public:
  
    bool dfs(int node, int par, vector<int> adj[], vector<bool> &visited){
        visited[node] = true;
        bool flag = false;
        for(auto it : adj[node]){
            if(!visited[it]){
                flag |= dfs(it, node, adj, visited);
                if(flag){
                    return true;
                }
            }else if(it != par){
                return true;
            }
        }
        return flag;
    }
  
    bool isCycle(int n, vector<int> adj[]) {
        vector<bool> visited(n, false);
        for(int i = 0; i < n; i++){
            if(!visited[i]){
                if(dfs(i, -1, adj, visited)){
                    return true;
                }
            }
        }        
        return false;
    }
};

-------------------------------------------------------------------------------------

            (minimum distance to all 0 to 1)

---maru

class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& arr) {
        int n = arr.size(), m = arr[0].size();
        vector<vector<int>> level(n, vector<int> (m, 1e9));
        queue<pair<int, int>> Q;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(arr[i][j] == 0){
                    Q.push({i, j});
                    level[i][j] = 0;
                }
            }
        } 
        vector<pair<int, int>> movement = {
            {-1, 0}, {0, 1}, {1, 0}, {0, -1}
        };
        while(!Q.empty()){
            auto f = Q.front();
            Q.pop();
            int i = f.first;
            int j = f.second;
            for(auto it : movement){
                int x = it.first + i;
                int y = it.second + j;
                if(x >= 0 && x < n && y >= 0 && y < m && 1 + level[i][j] < level[x][y]){
                    level[x][y] = 1 + level[i][j];
                    Q.push({x, y});
                }
            }
        }  
        return level; 
    }
};

---striver soluton is use visited and when we pop then mark as ij = dist;




