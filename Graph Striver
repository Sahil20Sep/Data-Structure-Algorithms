-----------------------------------------------------------------------------------------

    (intro)

node, vertex

directed cyclic/acyclic ggraph
undirected cyclic/acuclic graph

indgree --> number of incoming edge
outdegree --> number of outgoint edge

for undirected graph sum of total indegree = 2 * #ofedges

1 2 3 4 is path
then edges exits between adjecent node and do not repeat the visted node in path.

edges also contain weight if not then consider as 1.

if there is at least one cycle in graph callled cyclic graph.

--------------------------------------------------------------------------------------------

      (representation)

matrix
mat[n +1][n + 1];
mat[i][j] = 1 // represent i and j are connected

not usefull take O(N^2)

adj list
vector<int> adj[n + 1];

take only O(2E) space --> for undirected graph
take only (E) space --> for directed graph

---- about wt

mat[i][j] = wt;

in list we store pair adj[u].push_back({v,wt}];

-------------------------------------------------------------------------------------

        (connected componets)

maintain visited array 

run loop for 1 to n and check !vis[n] --> run_traversal(i);

------------------------------------------------------------------------------------

        (bfs)

---run for directed and undirected both

class Solution {
  public:
    vector<int> bfsOfGraph(int n, vector<int> adj[]) {
        vector<int> visited(n, false);
        visited[0] = true;
        queue<int> Q;
        Q.push(0);
        vector<int> bfs;
        while(!Q.empty()){
            int node = Q.front();
            Q.pop();
            bfs.push_back(node);
            for(auto it : adj[node]){
                if(!visited[it]){
                    visited[it] = true;
                    Q.push(it);
                }
            }
        }
        return bfs;
    }
};

space is O(2N) time is for directed O(N +E) and for undirected O(N + 2E).

----------------------------------------------------------------------------------------

            (dfs striver)

class Solution {
  public:
  
    void dfs(int node, vector<int> &ans, vector<int> adj[], vector<int> &visited){
        visited[node] = true;
        ans.push_back(node);
        for(auto it : adj[node]){
            if(!visited[it]){
                dfs(it, ans, adj, visited);
            }
        }
    }
  
    vector<int> dfsOfGraph(int n, vector<int> adj[]) {
        vector<int> visited(n, false);
        vector<int> ans;
        dfs(0, ans, adj, visited);
        return ans;
    }
};

space complexity O(N) + O(N) + recursion stack space O(N) if queue graph.
time complexity O(N + 2E)

--------------------------------------------------------------------------------------

                    (Number of Provinces)
----
class Solution {
public:

    void dfs(int node, vector<int> adj[], vector<int> &visited){
        visited[node] = true;
        for(auto it : adj[node]){
            if(!visited[it]){
                dfs(it, adj, visited);
            }
        }
    }

    int findCircleNum(vector<vector<int>>& arr) {
        int n = arr.size();
        vector<int> adj[n + 1];
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(arr[i][j] && i != j){
                    adj[i + 1].push_back(j + 1);
                    adj[j + 1].push_back(i + 1);
                }
            }
        }
        int cc = 0;
        vector<int> visited(n + 1, false);
        for(int i = 1; i <= n; i++){
            if(!visited[i]){
                cc++;
                dfs(i, adj, visited);
            }
        }
        return cc;
    }
};

space O(N) recursion stack space and O(N) visited
time O(N) + O(v + 2e)

---------------------------------------------------------------------

            (cc in matrix)

---bfs

class Solution {
public:

    void bfs(int i, int j, queue<pair<int, int>> &Q, vector<vector<bool>> &visited, vector<vector<char>> &arr, vector<pair<int, int>> &movement){
        int n = arr.size(), m = arr[0].size();
        visited[i][j] = true;
        Q.push({i, j});
        while(Q.size()){
            auto f = Q.front();
            Q.pop();
            for(auto it : movement){
                int x = f.first + it.first;
                int y = f.second + it.second;
                if(x >= 0 && x < n && y >= 0 && y < m && !visited[x][y] && arr[x][y] == '1'){
                    Q.push({x, y});
                    visited[x][y] = true;
                }
            }
        }
    }

    int numIslands(vector<vector<char>>& arr) {
        int n = arr.size(), m = arr[0].size();
        queue<pair<int, int>> Q;
        vector<vector<bool>> visited(n, vector<bool> (m, false));
        vector<pair<int, int>> movement = {
            {-1, 0}, {1, 0}, {0, 1}, {0, -1}
        };
        int cc = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(!visited[i][j] && arr[i][j] == '1'){
                    cc++;
                    bfs(i, j, Q, visited, arr, movement);
                }
            }
        }
        return cc;
    }
};

space O(N2) -- visited + O(N2) --> queue if all are 1
time O(N2) + 9 * O(N2)

--------------------------------------------------------------------------

        (flood fill)

class Solution {
public:

    void bfs(int i, int j, queue<pair<int, int>> &Q, vector<vector<bool>> &visited, vector<vector<char>> &arr, vector<pair<int, int>> &movement){
        int n = arr.size(), m = arr[0].size();
        visited[i][j] = true;
        Q.push({i, j});
        while(Q.size()){
            auto f = Q.front();
            Q.pop();
            for(auto it : movement){
                int x = f.first + it.first;
                int y = f.second + it.second;
                if(x >= 0 && x < n && y >= 0 && y < m && !visited[x][y] && arr[x][y] == '1'){
                    Q.push({x, y});
                    visited[x][y] = true;
                }
            }
        }
    }

    int numIslands(vector<vector<char>>& arr) {
        int n = arr.size(), m = arr[0].size();
        queue<pair<int, int>> Q;
        vector<vector<bool>> visited(n, vector<bool> (m, false));
        vector<pair<int, int>> movement = {
            {-1, 0}, {1, 0}, {0, 1}, {0, -1}
        };
        int cc = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(!visited[i][j] && arr[i][j] == '1'){
                    cc++;
                    bfs(i, j, Q, visited, arr, movement);
                }
            }
        }
        return cc;
    }
};

time 4 * n * m
space n * m

---------------------------------------------------------------------------------------

            (orange rotting)

class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        vector<vector<int>> arr = grid;
        int n = arr.size(), m = arr[0].size();
        queue<pair<pair<int, int>, int>> Q;
        vector<vector<bool>> visited(n, vector<bool> (m, false));
        int one = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(arr[i][j] == 2){
                    Q.push({{i, j}, 0});
                    visited[i][j] = true;
                }else if(arr[i][j] == 1){
                    one++;
                }
            }
        }
        if(one == 0){
            return 0;
        }
        vector<pair<int, int>> movement = {
            {-1, 0}, {0, -1}, {1, 0}, {0, 1}
        };
        int second = 0;
        while(Q.size()){
            auto f = Q.front();
            Q.pop();
            int time = f.second;
            if(time > second) second = time;
            for(auto it : movement){
                int x = f.first.first + it.first;
                int y = f.first.second + it.second;
                if(x >= 0 && x < n && y >= 0 && y < m && !visited[x][y] && arr[x][y] == 1){
                    Q.push({{x, y}, time + 1});
                    one--;
                    visited[x][y] = true;
                }
            }
        }
        return one ? -1 : second;
    }
};

-----

class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        vector<vector<int>> arr = grid;
        int n = arr.size(), m = arr[0].size();
        queue<pair<int, int>> Q;
        vector<vector<bool>> visited(n, vector<bool> (m, false));
        int one = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(arr[i][j] == 2){
                    Q.push({i, j});
                    visited[i][j] = true;
                }else if(arr[i][j] == 1){
                    one++;
                }
            }
        }
        if(one == 0){
            return 0;
        }
        vector<pair<int, int>> movement = {
            {-1, 0}, {0, -1}, {1, 0}, {0, 1}
        };
        int second = 0;
        while(Q.size()){
            int len = Q.size();
            second++;
            while(len--){
                auto f = Q.front();
                Q.pop();
                for(auto it : movement){
                    int x = f.first + it.first;
                    int y = f.second + it.second;
                    if(x >= 0 && x < n && y >= 0 && y < m && !visited[x][y] && arr[x][y] == 1){
                        Q.push({x, y});
                        one--;
                        visited[x][y] = true;
                    }
                }
            }
        }
        return one ? -1 : second - 1;
    }
};

-----

class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        vector<vector<int>> arr = grid;
        int n = arr.size(), m = arr[0].size();
        queue<pair<pair<int, int>, int>> Q;
        int one = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(arr[i][j] == 2){
                    Q.push({{i, j}, 0});
                }else if(arr[i][j] == 1){
                    one++;
                }
            }
        }
        if(one == 0){
            return 0;
        }
        vector<pair<int, int>> movement = {
            {-1, 0}, {0, -1}, {1, 0}, {0, 1}
        };
        int second = 0;
        while(Q.size()){
            auto f = Q.front();
            Q.pop();
            int time = f.second;
            if(time > second) second = time;
            for(auto it : movement){
                int x = f.first.first + it.first;
                int y = f.first.second + it.second;
                if(x >= 0 && x < n && y >= 0 && y < m && arr[x][y] == 1){
                    Q.push({{x, y}, time + 1});
                    one--;
                    arr[x][y] = 2;
                }
            }
        }
        return one ? -1 : second;
    }
};

----------------------------------------------------------------------------------------------

                (detect cycle -bfs)

class Solution {
  public:
  
    bool bfs(int i, vector<int> adj[], vector<bool> &visited){
        queue<pair<int, int>> Q;
        Q.push({i, -1});
        visited[i] = true;
        while(Q.size()){
            auto f = Q.front();
            Q.pop();
            int node = f.first;
            int par = f.second;
            for(auto it : adj[node]){
                if(!visited[it]){
                    visited[it] = true;
                    Q.push({it, node});
                }else if(par != it){
                    return true;
                }
            }
        }
        return false;
    }
  
    bool isCycle(int n, vector<int> adj[]) {
        vector<bool> visited(n, false);
        for(int i = 0; i < n; i++){
            if(!visited[i]){
                if(bfs(i, adj, visited)){
                    return true;
                }
            }
        }        
        return false;
    }
};

time n + n * 2*e
space 2n

-------------dfs

class Solution {
  public:
  
    bool dfs(int node, int par, vector<int> adj[], vector<bool> &visited){
        visited[node] = true;
        bool flag = false;
        for(auto it : adj[node]){
            if(!visited[it]){
                flag |= dfs(it, node, adj, visited);
                if(flag){
                    return true;
                }
            }else if(it != par){
                return true;
            }
        }
        return flag;
    }
  
    bool isCycle(int n, vector<int> adj[]) {
        vector<bool> visited(n, false);
        for(int i = 0; i < n; i++){
            if(!visited[i]){
                if(dfs(i, -1, adj, visited)){
                    return true;
                }
            }
        }        
        return false;
    }
};

-------------------------------------------------------------------------------------

            (minimum distance to all 0 to 1)

---maru

class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& arr) {
        int n = arr.size(), m = arr[0].size();
        vector<vector<int>> level(n, vector<int> (m, 1e9));
        queue<pair<int, int>> Q;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(arr[i][j] == 0){
                    Q.push({i, j});
                    level[i][j] = 0;
                }
            }
        } 
        vector<pair<int, int>> movement = {
            {-1, 0}, {0, 1}, {1, 0}, {0, -1}
        };
        while(!Q.empty()){
            auto f = Q.front();
            Q.pop();
            int i = f.first;
            int j = f.second;
            for(auto it : movement){
                int x = it.first + i;
                int y = it.second + j;
                if(x >= 0 && x < n && y >= 0 && y < m && 1 + level[i][j] < level[x][y]){
                    level[x][y] = 1 + level[i][j];
                    Q.push({x, y});
                }
            }
        }  
        return level; 
    }
};

---striver soluton is use visited and when we pop then mark as ij = dist;

-----------------------------------------------------------------------------------------

            (make o to x)

class Solution {
public:
    void solve(vector<vector<char>>& arr) {
        int n = arr.size(), m = arr[0].size();
        queue<pair<int, int>> Q;
        vector<pair<int, int>> movement = {
            {-1, 0}, {0, -1}, {1, 0}, {0, 1}
        };
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(i == 0 || i == n - 1 || j == 0 || j == m - 1){
                    if(arr[i][j] == 'O'){
                        Q.push({i, j});
                        arr[i][j] = '#';
                        while(Q.size()){
                            auto f = Q.front();
                            Q.pop();
                            for(auto it : movement){
                                int x = f.first + it.first;
                                int y = f.second + it.second;
                                if(x >= 0 && x < n && y >= 0 && y < m && arr[x][y] == 'O'){
                                    Q.push({x, y});
                                    arr[x][y] = '#';
                                }
                            }
                        }
                    }
                }
            }
        }
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(arr[i][j] == '#'){
                    arr[i][j] = 'O';
                }else{
                    arr[i][j] = 'X';
                }
            }
        }
    }
};

----------------------------------------------------------------------------------------

            (number of enclaves - same as above problem)

class Solution {
public:
    int numEnclaves(vector<vector<int>>& arr) {
        int n = arr.size(), m = arr[0].size();
        vector<pair<int, int>> movement = {
            {-1, 0}, {0, -1}, {1, 0}, {0, 1}
        };
        queue<pair<int, int>> Q;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(i == 0 || i == n - 1 || j == 0 || j == m - 1){
                    if(arr[i][j] == 1){
                        Q.push({i, j});
                        arr[i][j] = 2;
                        while(Q.size()){
                            auto f = Q.front();
                            Q.pop();
                            for(auto it : movement){
                                int x = it.first + f.first;
                                int y = it.second + f.second;
                                if(x >= 0 && x < n && y >= 0 && y < m && arr[x][y] == 1){
                                    arr[x][y] = 2;
                                    Q.push({x, y});
                                }
                            }
                        }
                    }
                }
            }
        }
        int ans = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m ;j++){
                if(arr[i][j] == 1){
                    ans++;
                }
            }
        }
        return ans;
    }
};

-------------------------------------------------------------------------------------------------------

            (nnumber of distict island)

class Solution {
  public:
    int countDistinctIslands(vector<vector<int>>& arr) {
        int n = arr.size(), m = arr[0].size();
        vector<vector<bool>> visited(n, vector<bool> (m, false));
        queue<pair<int, int>> Q;
        vector<pair<int, int>> movement = {
            {-1, 0}, {1, 0}, {0, -1}, {0, 1}  
        };
        set<vector<pair<int, int>>> ms;
        vector<pair<int, int>> store;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(!visited[i][j] && arr[i][j]){
                    Q.push({i, j});
                    store.push_back({0, 0});
                    visited[i][j] = true;
                    while(!Q.empty()){
                        auto f = Q.front();
                        Q.pop();
                        for(auto it : movement){
                            int x = f.first + it.first;
                            int y = f.second + it.second;
                            if(x >= 0 && x < n && y >= 0 && y < m && arr[x][y] == 1 && !visited[x][y]){
                                Q.push({x, y});
                                store.push_back({x - i, y - j});
                                visited[x][y] = true;
                            }
                        }
                    }
                    ms.insert(store);
                    store.clear();
                }
            }
        }
        return (int)ms.size();
    }
};

time n * m * log(n*m) + 4 * n * m

-----------------------------------------------------------------------------------------

                    (check bipertite graph or not)


class Solution {
public:

    bool dfs(int node, int par, vector<vector<int>> &arr, vector<int> &visited){
        if(par == -1){
            visited[node] = 1;
        }else{
            visited[node] = visited[par] == 2 ? 1 : 2;
        }
        for(auto child : arr[node]){
            if(!visited[child]){
                if(dfs(child, node, arr, visited)){
                    return true;
                }
            }else if(visited[child] == visited[node]){
                return true;
            }
        }
        return false;
    }

    bool isBipartite(vector<vector<int>>& arr) {
        int n = arr.size();
        vector<int> visited(n, 0);
        for(int i = 0; i <n; i++){
            if(!visited[i]){
                if(dfs(i, -1, arr, visited)){
                    return false;
                }
            }
        }
        return true;
    }
};

----bfs

class Solution {
public:

    bool isBipartite(vector<vector<int>>& arr) {
        int n = arr.size();
        vector<int> visited(n, 0);
        queue<int> Q;
        for(int i = 0; i < n; i++){
            if(!visited[i]){
                Q.push(i);
                visited[i] = 1;
                while(Q.size()){
                    auto f = Q.front();
                    Q.pop();
                    for(auto child : arr[f]){
                        if(!visited[child]){
                            Q.push(child);
                            visited[child] = visited[f] == 2 ? 1 : 2;
                        }else if(visited[f] == visited[child]){
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    }
};

-------------------------------------------------------------------------------------

    (detect cycle in directed graph)

---in the same path node have to visited again. called cycle

class Solution {
  public:
  
    bool dfs(int node, vector<bool> &visited, vector<bool> &path, vector<int> adj[]){
        visited[node] = true;
        path[node] = true;
        for(auto child : adj[node]){
            if(!visited[child]){
                if(dfs(child, visited, path, adj)){
                    return true;
                }
            }else if(path[child]) {
                return true;
            }
        }
        path[node] = false;
        return false;
    }
  
    bool isCyclic(int n, vector<int> adj[]) {
        vector<bool> visited(n, false), path(n, false);
        for(int i = 0; i < n; i++){
            if(!visited[i]){
                if(dfs(i, visited, path, adj)){
                    return true;
                }
            }
        }
        return false;
    }
};

time is n + e (because of directed graph)

-----1 vvector solution

class Solution {
  public:
  
    bool dfs(int node, vector<int> &visited, vector<int> adj[]){
        visited[node] = 2;
        for(auto child : adj[node]){
            if(!visited[child]){
                if(dfs(child, visited, adj)){
                    return true;
                }
            }else if(visited[child] == 2){
                return true;
            }
        }
        visited[node] = 1;
        return false;
    }
  
    bool isCyclic(int n, vector<int> adj[]) {
        vector<int> visited(n, 0);
        for(int i = 0; i < n; i++){
            if(!visited[i]){
                if(dfs(i, visited, adj)){
                    return true;
                }
            }
        }
        return false;
    }
};

------------------------------------------------------------------------
        (find eventual safe states)

----one vector solution above question same some changes)

class Solution {
public:

    bool dfs(int node, vector<int> &ans, vector<vector<int>> &arr, vector<int> &visited){
        visited[node] = 2;
        for(auto child : arr[node]){
            if(!visited[child]){
                if(dfs(child, ans, arr, visited)){
                    return true;
                }
            }else if(visited[child] == 2){
                return true;
            }
        }
        visited[node] = 1;
        ans.push_back(node);
        return false;
    }

    vector<int> eventualSafeNodes(vector<vector<int>>& arr) {
        int n = arr.size();
        vector<int> visited(n, 0);
        vector<int> ans;
        for(int i = 0; i < n; i++){
            if(!visited[i]){
                dfs(i, ans, arr, visited);
            }
        }
        sort(ans.begin(), ans.end());
        return ans;
    }
};

-------------------------------------------------------------------------------------

            (topo logical sort)

if there is edge between u and v then u must be apper before v in array.

only apply on DAG.

topo is working only for directed acyclic graph.

not for directed cyclic graph.

----dfs

use stack

class Solution
{
	public:

	void dfs(int node, vector<int> adj[], vector<bool> &visited, stack<int> &st){
	    visited[node] = true;
	    for(auto child : adj[node]){
	        if(!visited[child]){
	            dfs(child, adj, visited, st);
	        }
	    }
	    st.push(node);
	}
	
	vector<int> topoSort(int n, vector<int> adj[]) 
	{
	    vector<int> ans;
	    vector<bool> visited(n, false);
	    stack<int> st;
	    for(int i = 0; i < n; i++){
	        if(!visited[i]){
	            dfs(i, adj, visited, st);
	        }
	    }
	    while(st.size()){
	        ans.push_back(st.top());
	        st.pop();
	    }
	    return ans;
	}
};

TIME V + e AND space is 2N

-----bfs

vector<int> topoSort(int n, vector<int> adj[]) 
	{
	    vector<int> ans, indegree(n, 0);
	    for(int i = 0; i < n; i++){
	        for(auto it : adj[i]){
	            indegree[it]++;
	        }
	    }
	    queue<int> Q;
	    for(int i = 0; i < n; i++){
	        if(indegree[i] == 0){
	            Q.push(i);
	        }
	    }
	    while(Q.size()){
	        auto f = Q.front();
	        Q.pop();
	        ans.push_back(f);
	        for(auto child : adj[f]){
	            indegree[child]--;
	            if(indegree[child] == 0){
	                Q.push(child);
	            }
	        }
	    }
	    return ans;
	}

v + e and 2n space

-----------------------------------------------------------------------------------

		(cycle detection in directed grpah - bfs, topo)

class Solution {
  public:
  
    bool isCyclic(int n, vector<int> adj[]) {
        vector<int> in(n, 0);
        int cnt = 0;
        for(int i = 0; i < n; i++){
            for(auto it : adj[i]){
                in[it]++;
            }
        }
        queue<int> Q;
        for(int i = 0; i < n; i++){
            if(in[i] == 0){
                Q.push(i);
            }
        }
        while(Q.size()){
            auto f= Q.front();
            cnt++;
            Q.pop();
            for(auto child : adj[f]){
                in[child]--;
                if(in[child] == 0){
                    Q.push(child);
                }
            }
        }
        return cnt == n ? false : true;
    }
};
