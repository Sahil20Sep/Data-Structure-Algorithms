          (stack implement using array)

void MyStack :: push(int x)
{
    top++;
    arr[top] = x;
}

int MyStack :: pop()
{
    if(top == -1){
        return -1;
    }
    return arr[top--];
}

for size return (top + 1) and empty return (top == -1)

------------------------------------------------------------------------------

      (queue implement using array)

void push(int x){

        if(cnt < n){
            cnt++;
            arr[rear % n] = x;
            rear++;
        }

        return -1;
    }

    void pop(){

        if(cnt == 0){
            // no element
        }
        
        a[front % n] = -1;
        cnt--;
        front++;

    }

    void top(){

        if(cnt == 0){
            // no element
        }
        
        return a[front % n];
    }

-------------------

void MyQueue :: push(int x)
{
    arr[rear++] = x;
}

int MyQueue :: pop()
{
    if(rear == front){
        return -1;
    }
    return arr[front++]; 
}

determine size and empty we use cnt;

--------------------------------------------------------------------------------------------------------

                (implement stack using 2-queue)

class MyStack {
public:

    queue<int> Q1, Q2;

    MyStack() {
        
    }
    
    void push(int x) {
        
        Q2.push(x);

        while(!Q1.empty()){

            Q2.push(Q1.front());
            Q1.pop();

        }

        swap(Q1, Q2);
    }
    
    int pop() {
        
        int ans = Q1.front();
        Q1.pop();
        return ans;

    }
    
    int top() {
        
        return Q1.front();

    }
    
    bool empty() {
        
        return Q1.empty();

    }
};

space is 2* N

------------------

        (using one queue)

class MyStack {
public:

    queue<int> Q1;

    MyStack() {
        
    }
    
    void push(int x) {
        
        Q1.push(x);

        int cnt = 0, n = Q1.size();

        while(cnt != n - 1){

            cnt++;
            Q1.push(Q1.front());
            Q1.pop();

        }

    }
    
    int pop() {
        
        int ans = Q1.front();
        Q1.pop();
        return ans;

    }
    
    int top() {
        
        return Q1.front();

    }
    
    bool empty() {
        
        return Q1.empty();

    }
};

space N

-------------------------------------------------------------------------------------------------

        (implement queue using 2-stack)

class MyQueue {
public:

    stack<int> st1, st2;

    MyQueue() {
        
    }
    
    void push(int x) {
        
        while(!st1.empty()){

            st2.push(st1.top());
            st1.pop();

        }

        st1.push(x);

        while(!st2.empty()){

            st1.push(st2.top());
            st2.pop();

        }

    }
    
    int pop() {
        
        int ans = st1.top();
        
        st1.pop();

        return ans;

    }
    
    int peek() {
        
        return st1.top();

    }
    
    bool empty() {
        
        return st1.empty();

    }
};

-------------------------------------

        (implement using input and output stack)

class MyQueue {
public:

    stack<int> input, output;

    MyQueue() {
        
    }
    
    void push(int x) {

        input.push(x);

    }
    
    int pop() {
        
        if(output.empty()){

            while(!input.empty()){

                output.push(input.top());
                input.pop();

            }

        }

        int ans = output.top();
        output.pop();

        return ans;

    }
    
    int peek() {
        
        if(output.empty()){

            while(!input.empty()){

                output.push(input.top());
                input.pop();
                
            }

        }

        int ans = output.top();

        return ans;

    }
    
    bool empty() {
        
        return input.empty() && output.empty();

    }
};

--------------------------------------------------------------------------------

                              (check for valid paretheess)

class Solution {
public:
    bool isValid(string s) {
        
        int n = s.size();

        if(n & 1){
            return false;
        }

        stack<char> st;

        for(int i = 0; i < n; i++){

            if(s[i] == '(' || s[i] == '{' || s[i] == '['){
                st.push(s[i]);
                continue;
            }

            if(st.empty()){
                return false;
            }

            if((s[i] == ')' && st.top() != '(') || (s[i] == ']' && st.top() != '[') || (s[i] == '}' && st.top() != '{')){
                return false;
            }else{
                st.pop();
            }

        }

        return st.empty() ? true : false;
    }
};

-------------------------------------------------------------------------------------------------------

                              (next greater element I --> monotonic stack)

class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& a, vector<int>& b) {
        
        stack<int> st;

        map<int, int> hash;

        for(int i = 0; i < b.size(); i++){

            hash[b[i]] = i;

        }

        int n = b.size();

        vector<int> ans(n, -1);

        for(int i = n - 1; i >= 0; i--){

            while(!st.empty() && st.top() < b[i]){

                st.pop();

            }

            if(!st.empty()){

                ans[i] = st.top();

            }

            st.push(b[i]);

        }

        vector<int> fi;

        for(int i = 0; i < a.size(); i++){

            fi.push_back(ans[hash[a[i]]]);

        }

        return fi;
    }
};

------------------------------------------------------------------------------------------------------------

                              (next greater element II)

class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& arr) {

        int n = arr.size();

        vector<int> ans(n, -1);

        stack<int> st;

        for(int i = (n << 1) - 1; i >= 0; i--){

            while(!st.empty() && st.top() <= arr[i % n]){

                st.pop();

            }

            if(!st.empty()){

                ans[i % n] = st.top();

            }

            st.push(arr[i % n]);

        }

        return ans;

    }
};

using cnt++ to relize time complxity;

O(2*N + 2*N) --> time and O(N) --> space

--------------------------------------------------------------------------------------------------------------

                              (Next smaller element)

vector<int> Solution::prevSmaller(vector<int> &arr) {
    
    stack<int> st;
    
    int n = arr.size();
    
    vector<int> ans(n, -1);
    
    for(int i = 0; i < n; i++){
        
        while(!st.empty() && st.top() >= arr[i]){
            
            st.pop();
            
        }
        
        if(!st.empty()){
            
            ans[i] = st.top();
            
        }
        
        st.push(arr[i]);
        
    }
    
    return ans;

}

-------------------------------------------------------------------------------------------------------------

                              (count the number of greter element after the index)

class Solution{
public:

    vector<int> count_NGE(int n, vector<int> &arr, int queries, vector<int> &ind){
        
        vector<int> ans(ind.size());
        
        for(int i = 0; i < ind.size(); i++){
            
            int index = ind[i], cnt = 0;
            
            for(int j = index + 1; j < arr.size(); j++){
                
                if(arr[j] > arr[index]){
                    
                    cnt++;
                    
                }
            }
            
            ans[i] = cnt;
        }
        
        return ans;
       
    }

};

------------------------------------------------------------------------------------------------------------------

                    (Trapping the water)

class Solution {
public:
    int trap(vector<int>& height) {
        
        int n = height.size();

        vector<int> left(n), right(n);

        int mx = 0;

        for(int i = 0; i < n; i++){

            if(height[i] > mx){
                mx = height[i];
            }

            left[i] = mx;

        }

        mx = 0;

        for(int i = n - 1; i >= 0; i--){

            if(height[i] > mx){
                mx = height[i];
            }

            right[i] = mx;

        }

        int ans = 0;

        for(int i = 0; i < n; i++){

            ans += min(left[i], right[i]) - height[i];

        }

        return ans;

    }
};
