    (fibonacci)

class Solution {
  public:
    long long mod = 1e9 + 7;
    long long func(int n, vector<long long> &dp){
        if(n <= 1){
            return n;
        }
        if(dp[n] != -1){
            return dp[n];
        }
        return dp[n] = (func(n - 1, dp) + func(n - 2, dp)) % mod;
    }
  
    long long int topDown(int n) {
        vector<long long> dp(n + 1, -1);
        return func(n, dp);
    }
    long long int bottomUp(int n) {
        int prev2 = 0, prev1= 1;
        for(int i = 2; i <= n; i++){
            int cur = (prev1 + prev2) % mod;
            prev2 = prev1;
            prev1 = cur;
        }
        return prev1;
    }
};

---------------------------------------------------------------------------------------------

            (distinct way to climb stair)

-----memo (use base case as i = 0 and i = 1 return 1;

class Solution {
public:

    int func(int i, vector<int> &dp){
        
        if(i == 0 || i == 1){
            return 1;
        }
        if(dp[i] != -1){
            return dp[i];
        }
        return dp[i] = func(i - 1, dp) + func(i - 2, dp);
    }

    int climbStairs(int n) {
        vector<int> dp(n + 1, -1);
        return func(n, dp);
    }
};

---tab

class Solution {
public:

    int climbStairs(int n) {
        vector<int> dp(n + 1, -1);
        dp[0] = 1, dp[1] = 1;
        for(int i = 2; i <= n; i++){
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};

-------opti

class Solution {
public:

    int climbStairs(int n) {
        int prev2 = 1, prev = 1;
        for(int i = 2; i <= n; i++){
            int cur = prev + prev2;
            prev2 = prev;
            prev = cur;
        }
        return prev;
    }
};

----------------------------------------------------------------------------------
        (min energy to reach n -1 index)

----momo

class Solution {
  public:
  
    int func(int i, vector<int> &arr, vector<int> &dp){
        if(i == 0){
            return 0;
        }
        if(dp[i] != -1){
            return dp[i];
        }
        int ans = 1e9;
        if(i - 1 >= 0) ans = min(ans, func(i - 1, arr, dp) + abs(arr[i] - arr[i - 1]));
        if(i - 2 >= 0) ans = min(ans, func(i - 2, arr, dp) + abs(arr[i] - arr[i - 2]));
        return dp[i] = ans;
    }
  
    int minimumEnergy(vector<int>& arr, int n) {
        vector<int> dp(n, -1);
        return func(n - 1, arr, dp);
    }
};

-----tab

int minimumEnergy(vector<int>& arr, int n) {
    vector<int> dp(n, 1e9);
    dp[0] = 0;
    for(int i = 1; i < n; i++){
        if(i - 1 >= 0) dp[i] = min(dp[i], dp[i - 1] + abs(arr[i] - arr[i - 1]));
        if(i - 2 >= 0) dp[i] = min(dp[i], dp[i - 2] + abs(arr[i] - arr[i - 2]));
    }
    return dp[n - 1];
}\

---------opti

int minimumEnergy(vector<int>& arr, int n) {
        int prev2 = 0, prev1 = 0;
        for(int i = 1; i < n; i++){
            int ans = 1e9;
            if(i - 1 >= 0) ans = min(ans, prev1 + abs(arr[i] - arr[i - 1]));
            if(i - 2 >= 0) ans = min(ans, prev2 + abs(arr[i] - arr[i - 2]));
            prev2 = prev1;
            prev1 = ans;
        }
        return prev1;
    }

----------------------------------------------------------------------------------------------

        (frog K jump)

------memo

class Solution {
  public:
  
    int func(int i, int k, vector<int> &arr, vector<int> &dp){
        if(i == 0){
            return 0;
        }
        if(dp[i] != -1){
            return dp[i];
        }
        int ans = 1e9 + 1;
        for(int j = 1; j <= k; j++){
            if(i - j >= 0){
                ans = min(ans, func(i - j, k, arr, dp) + abs(arr[i] - arr[i - j]));
            }
        }
        return dp[i] = ans;
    }
  
    int minimizeCost(vector<int>& arr, int n, int k) {
        vector<int> dp(n, -1);
        return func(n - 1, k, arr, dp);
    }
};


----------tab

int minimizeCost(vector<int>& arr, int n, int k) {
    vector<int> dp(n, -1);
    dp[0] = 0;
    for(int i = 1; i < n; i++){
        int ans = 1e9 + 1;
        for(int j = 1; j <= k; j++){
            if(i - j >= 0){
                ans = min(ans, dp[i - j] + abs(arr[i] - arr[i - j]));
            }
        }
        dp[i] = ans;
    }
    return dp[n - 1];
}

--------space not require because worse case k = n take place, o/w take vector of k size and samelogic of above problem move by 1.


--------------------------------------------------------------------------------------------

        house robbar

---memo

class Solution {
public:

    int func(int i, vector<int> &arr, vector<int> &dp){
        if(i < 0){
            return 0;
        }
        if(dp[i] != -1){
            return dp[i];
        }
        int ans = -1;
        ans = max(ans, arr[i] + func(i - 2, arr, dp));
        ans = max(ans, func(i - 1, arr, dp));
        return dp[i] = ans;
    }

    int rob(vector<int>& arr) {
        int n = arr.size();
        vector<int> dp(n, -1);
        return func(n - 1, arr, dp);
    }
};

-------tab

int rob(vector<int>& arr) {
    int n = arr.size();
    vector<int> dp(n, -1);
    for(int i = 0; i < n; i++){
        int ans = -1;
        ans = max(ans, arr[i] + (i - 2 < 0 ? 0 : dp[i - 2]));
        ans = max(ans, (i - 1 < 0 ? 0 : dp[i - 1]));
        dp[i] = ans;
    }
    return dp[n - 1];
}

-------space

int rob(vector<int>& arr) {
    int n = arr.size();
    int prev2 = 0, prev1 = 0;
    for(int i = 0; i < n; i++){
        int ans = -1;
        ans = max(ans, arr[i] + (i - 2 < 0 ? 0 : prev2));
        ans = max(ans, (i - 1 < 0 ? 0 : prev1));
        prev2 = prev1;
        prev1 = ans;
    }
    return prev1;
}

-----------------------------------------------------------------------
        first and last are also adjecent.

class Solution {
public:

    int func(vector<int>& arr) {
        int n = arr.size();
        int prev2 = 0, prev1 = 0;
        for(int i = 0; i < n; i++){
            int ans = -1;
            ans = max(ans, arr[i] + (i - 2 < 0 ? 0 : prev2));
            ans = max(ans, (i - 1 < 0 ? 0 : prev1));
            prev2 = prev1;
            prev1 = ans;
        }
        return prev1;
    }

    int rob(vector<int>& arr) {
        int n = arr.size();
        if(n == 1){
            return arr[0];
        }
        vector<int> temp1(arr.begin(), arr.begin() + n - 1), temp2(arr.begin() + 1, arr.end());
        return max(func(temp1), func(temp2));
    }
};

----------------------------------------------------------------------------------

        (ninja traning)

-----memo

class Solution {
  public:
  
    int func(int i, int days, vector<vector<int>>& arr, vector<vector<int>>& dp){
        if(i == 0){
            int ans = -1;
            for(int j = 0; j < 3; j++){
                if(j != days){
                    ans = max(ans, arr[i][j]);
                }
            }
            return dp[i][days] = ans;
        }
        if(dp[i][days] != -1){
            return dp[i][days];
        }
        int ans = -1;
        for(int j = 0; j < 3; j++){
            if(j != days){
                ans = max(ans, arr[i][j] + func(i - 1, j, arr, dp));
            }
        }
        return dp[i][days] = ans;
    }
  
    int maximumPoints(vector<vector<int>>& arr, int n) {
        vector<vector<int>> dp(n, vector<int> (4, -1));
        return func(n - 1, 3, arr, dp);
    }
};

-------tab

int maximumPoints(vector<vector<int>>& arr, int n) {
    vector<vector<int>> dp(n, vector<int> (4, -1));
    dp[0][0] = max(arr[0][1], arr[0][2]);
    dp[0][1] = max(arr[0][0], arr[0][2]);
    dp[0][2] = max(arr[0][0], arr[0][1]);
    dp[0][3] = max({arr[0][0], arr[0][1], arr[0][2]});
    for(int i = 1; i < n; i++){
        for(int days = 0; days <= 3; days++){
            int ans = -1;
            for(int j = 0; j < 3; j++){
                if(j != days){
                    ans = max(ans, arr[i][j] + dp[i - 1][j]);
                }
            }
            dp[i][days] = ans;
        }
    }
    return dp[n - 1][3];
}

-----space

int maximumPoints(vector<vector<int>>& arr, int n) {
    vector<int> prev(4, -1), curr(4, -1);
    prev[0] = max(arr[0][1], arr[0][2]);
    prev[1] = max(arr[0][0], arr[0][2]);
    prev[2] = max(arr[0][0], arr[0][1]);
    prev[3] = max({arr[0][0], arr[0][1], arr[0][2]});
    for(int i = 1; i < n; i++){
        for(int days = 0; days <= 3; days++){
            int ans = -1;
            for(int j = 0; j < 3; j++){
                if(j != days){
                    ans = max(ans, arr[i][j] + prev[j]);
                }
            }
            curr[days] = ans;
        }
        prev = curr;
    }
    return prev[3];
}

-------------------------------------------------------------------------------------
        (unique path top left to bottam right)

----memo

class Solution {
public:

    int func(int i, int j, int m, int n, vector<vector<int>> &dp){
        if(i == 0 && j == 0){
            return 1;
        }
        if(i < 0 || j < 0){
            return 0;
        }
        if(dp[i][j] != -1){
            return dp[i][j];
        }
        int ans = 0;
        ans += func(i - 1, j, m, n, dp);
        ans += func(i, j - 1, m, n, dp);
        return dp[i][j] = ans;
    }

    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int> (n, -1));
        return func(m - 1, n - 1, m, n, dp);
    }
};

------- tab

int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int> (n, -1));
        dp[0][0] = 1;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(i == 0 && j == 0){
                    continue;
                }
                int ans = 0;
                if(i - 1 >= 0) ans += dp[i - 1][j];
                if(j - 1 >= 0) ans += dp[i][j - 1];
                dp[i][j] = ans;
            }
        }
        return dp[m - 1][n - 1];
    }

----space

int uniquePaths(int m, int n) {
        vector<int> prev(n, 0), curr(n, 0);
        curr[0] = 1;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(i == 0 && j == 0){
                    continue;
                }
                int ans = 0;
                if(i - 1 >= 0) ans += prev[j];
                if(j - 1 >= 0) ans += curr[j - 1];
                curr[j] = ans;
            }
            prev = curr;
        }
        return prev[n - 1];
    }

-----------------------------------------------------------------------------

        (unique path with obstackle)

----memo

class Solution {
public:

    int func(int i, int j, vector<vector<int>> &arr, vector<vector<int>> &dp){
        if(i < 0 || j < 0){
            return 0;
        } 
        if(arr[i][j]){
            return dp[i][j] = 0;
        }
        if(i == 0 && j == 0){
            return 1;
        }
        if(dp[i][j] != -1){
            return dp[i][j];
        }
        int ans = 0;
        ans += func(i - 1, j, arr, dp);
        ans += func(i, j - 1, arr, dp);
        return dp[i][j] = ans;
    }

    int uniquePathsWithObstacles(vector<vector<int>>& arr) {
        int n = arr.size(), m = arr[0].size();
        vector<vector<int>> dp(n, vector<int> (m, -1));
        return func(n - 1, m - 1, arr, dp);
    }
};

-----tab

int uniquePathsWithObstacles(vector<vector<int>>& arr) {
        int n = arr.size(), m = arr[0].size();
        vector<vector<int>> dp(n, vector<int> (m, 0));
        if(arr[0][0] == 0){
            dp[0][0] = 1;
        }
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(i == 0 && j == 0) continue;
                if(arr[i][j]){
                    dp[i][j] = 0;
                    continue;
                }
                int ans = 0;
                if(i - 1 >= 0) ans += dp[i - 1][j];
                if(j - 1 >= 0) ans += dp[i][j - 1];
                dp[i][j] = ans;
            }
        }
        return dp[n - 1][m - 1];
    }

------space

int uniquePathsWithObstacles(vector<vector<int>>& arr) {
        int n = arr.size(), m = arr[0].size();
        vector<int> prev(m, 0), curr(m, 0);
        if(arr[0][0] == 0){
            curr[0] = 1;
        }
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(i == 0 && j == 0) continue;
                if(arr[i][j]){
                    curr[j] = 0;
                    continue;
                }
                int ans = 0;
                if(i - 1 >= 0) ans += prev[j];
                if(j - 1 >= 0) ans += curr[j - 1];
                curr[j] = ans;
            }
            prev = curr;
        }
        return prev[m - 1];
    }

----------------------------------------------------------------------------------

    (minimum path sum -- right and bottam)

----memo

class Solution {
public:

    int func(int i, int j, vector<vector<int>> &arr, vector<vector<int>> &dp){
        int n = arr.size(), m = arr[0].size();
        if(i == 0 && j == 0){
            return dp[i][j] = arr[0][0];
        }
        if(i < 0 || j < 0){
            return 1e9 + 1;
        }
        if(dp[i][j] != -1){
            return dp[i][j];
        }
        int ans = 1e9;
        ans = min(ans, arr[i][j] + func(i - 1, j, arr, dp));
        ans = min(ans, arr[i][j] + func(i, j - 1, arr, dp));
        return dp[i][j] = ans;
    }

    int minPathSum(vector<vector<int>>& arr) {
        int n = arr.size(), m = arr[0].size();
        vector<vector<int>> dp(n, vector<int> (m, -1));
        return func(n - 1, m - 1, arr, dp);
    }
};

-----tabular

int minPathSum(vector<vector<int>>& arr) {
    int n = arr.size(), m = arr[0].size();
    vector<vector<int>> dp(n, vector<int> (m, 0));
    dp[0][0] = arr[0][0];
    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            if(i == 0 && j == 0){
                continue;
            }
            int ans = 1e9;
            if(i - 1 >= 0) ans = min(ans, arr[i][j] + dp[i - 1][j]);
            if(j - 1 >= 0) ans = min(ans, arr[i][j] + dp[i][j - 1]);
            dp[i][j] = ans;
        }
    }
    return dp[n - 1][m - 1];
}

----space

int minPathSum(vector<vector<int>>& arr) {
    int n = arr.size(), m = arr[0].size();
    vector<int> curr(m, 0), prev(m, 0);
    curr[0] = arr[0][0];
    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            if(i == 0 && j == 0){
                continue;
            }
            int ans = 1e9;
            if(i - 1 >= 0) ans = min(ans, arr[i][j] + prev[j]);
            if(j - 1 >= 0) ans = min(ans, arr[i][j] + curr[j - 1]);
            curr[j] = ans;
        }
        prev = curr;
    }
    return prev[m - 1];
}
