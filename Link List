difference between array and linklist

where is used? --> stack and queue

real life example --> brower --> search --> takeyouforward --> take probblem --> leetcode / also do back tracking (double link list)
singly link list --> todo list

Node* y = new Node();
cout << y // give the address
cout << y.data // gives error
cout << y->data // gives y data
cout << y.next // gives error
cout << y-> next // give next address

because here y is ptr so use ->

Node y = Node();
y is object
cout << y // give error
cout << y -> data // gives error
cout << y.data // gives data

because here y is object so use .

32 bit architecture --> ptr take 4 byte
64 bit architecture --> ptr take 8 byte

never ever change the head pointer take temp pointer.

-----------------------------------------------------------

    (array to linklist)

simple question

  (traverse in linklist) --> O(N) time

-------------------------------------------------------


length of linklist O(N) time

-------------------------------------------------------

search in link list

-------------------------------------------------------

      (delete a node)

---head

if head is null return null;
create temp = head;
head = head -> next;
delete temp;

return head;

---tail

if(head is null or head -> next == nULl) return null;
while(temp -> next -> next)

delete(temp -> next)
temp -> next = NULL;

---delete kth element in linklist

write the logic for head

store current and prev node ;

prev -> next = prev -> next -> next;

----delete input val node

-------------------------------------------------------

        (insert)

----head

temp -> next = head;
return temp; // do not change the head.

----tail

head == null return new Node(5);

while(temp -> next)

----in betwween

if(head == NULL ) and k == 1 then insert o/w return null;

if(k == 1) temp -> next = head;

temp -> next = new Node();
return head;

if(k >= 2)
  while(temp)
  cnt++
  if(cnt == k - 1)
    x = new node;
    x -> next = temp -> next;
    temp -> next = x;

----insert before value

head == NULL return null;

if(head -> val == givenVal)

while(temp -> next)
  cnt++
  if(temp -> next -> data == GiveVal)
    x = new node;
    x -> next = temp -> next;
    temp -> next = x;

if value was not there in linklist return not present.

----------------------------------------------------------------
          doubly link list real time is browers

---struct
val
next
prev

----array into double linklist

new node-> back = prev;
prev -> next = new Node;
prev = new node;
return head;

--------------------------------------------------------------------------
          (delete a node)

---head of the linklist

head == null || head -> next = null return null

prev = head;
head = head -> nexxt;
head -> prev = null;
prev -> next = null;
delete(prev)
return head;

----tail 

while(tail-> next)


prev = teil -> back;
prev -> next = null;
tail -> back = null

-----kth element   (k 1 to n)

head = null return null

directly traverse to k node

then 

take prev 
take next
left = temp -> prev;
right = temp -> next;

if(left == null and right == null) return null // single node 
if(left == null) // head
if(right == null) // tail

left -> next = right;
right -> prev = left;

temp -> next = null;
temp -> prev = null;

delete(temp)
return head;

------delete give node


prev = temp -> prev;
next = temp -> next;

if(next == NULL)  //tail
  prev -> next = null;
  temp -> back = null
  free(temp);

prev -> next = next;
front -> prev = prev;

temp -> next = temp-> back = null;

-----------------------------------------------------------

          (insert the node) - before the node

----before head

new node

new node -> next = head;
head -> prev = newNode;
return new Node;

----before tail

single node // same as before head call just

> 1 node;

whiel(teil-> next)

prev = tail -> pev
new node(val, tail, prev)
prev -> nexxt = new node
tail -> back = new node;

------before kth element

itrerate throught k

if(k=1) before head will be called.

while(temp != null)
cnt++
if(cnt == k)
break;

temp is current now. // before this 

prev = temp -> pev
new node(val, temp, prev)
prev -> nexxt = new node
tail -> back = new node;

------before the node

prev = node -> pev
new node(val, node, prev)
prev -> next = neww node
node -> back = new node

-----------------------------------------------------------------

            (reverse the doubly link list)

----brute force

use stack and iterate through link list.
now temp again = head;
and head -> data = st.top();

2n time and n space

-----most optimized

class Solution
{
    public:
    Node* reverseDLL(Node * head)
    {
        if(head == NULL || head -> next == NULL){
            return head;
        }
        Node* curr = head;
        Node* last = NULL;
        while(curr != NULL){
            last = curr -> prev;
            curr -> prev = curr -> next;
            curr -> next = last;
            curr = curr -> prev;
        }
        return last -> prev;
    }
};

n time and constant

-------------------------------------------------------------
        (adding two number)

when we are require to store a new list always use dummy node.

----optimized

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* temp1 = l1;
        ListNode* temp2 = l2;
        int carry = 0;
        ListNode* dummyNode = new ListNode(-1);
        ListNode* curr = dummyNode;
        while(temp1 || temp2){
            int sum = 0;
            sum += carry;
            if(temp1){
                sum += temp1 -> val;
            }
            if(temp2){
                sum += temp2 -> val;
            }
            curr -> next = new ListNode(sum % 10);
            curr = curr -> next;
            carry = sum / 10;
            if(temp1){
                temp1 = temp1 -> next;
            }
            if(temp2){
                temp2 = temp2 -> next;
            }
        }
        if(carry){
            curr -> next = new ListNode(1);
        }
        return dummyNode -> next;
    }
};

time max(l1, l2)
space max(l1,l2) --> for storeing result // i can't optimize it.

---------------------------------------------------------------------------------

        (odd even link list)

----brute force is data replacement

first go through all odd nodes temp -> next -> next // n/2
secodn go through all event nodes temp -> next -> next // n/ 2

then do data replacement 

timme 2n
space n

class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(head == NULL){
            return NULL;
        }
        vector<int> data;
        ListNode* temp = head;
        while(temp && temp -> next){
            data.push_back(temp -> val);
            temp = temp -> next -> next;
        }
        if(temp){
            data.push_back(temp -> val);
        }
        temp = head -> next;
        while(temp && temp -> next){
            data.push_back(temp -> val);
            temp = temp -> next -> next;
        }
        if(temp){
            data.push_back(temp -> val);
        }
        temp = head;
        int i = 0;
        while(temp){
            temp -> val = data[i++];
            temp = temp -> next;
        }
        return head;
    }
};

-----optimized

class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(head == NULL || head -> next == NULL){
            return head;
        }
        ListNode* odd = head;
        ListNode* even = head -> next;
        ListNode* evenHead = head -> next;
        while(even && even -> next){
            odd -> next = odd -> next -> next;
            even -> next = even -> next -> next;
            odd = odd -> next;
            even = even -> next;
        }
        odd -> next = evenHead;
        return head;
    }
};

time is n/2
space 1;

------------------------------------------------------------------------------


    (sort 0 1 and 2)

---brute force data replacement

take the cnt0, cnt1, cnt2

and then again run loop and make data replacement

time is 2n space is 1

-----most optimized (create three different link list)

class Solution
{
    public:
    
    Node* segregate(Node *head) {
        Node* zeroHead = new Node(-1);
        Node* oneHead = new Node(-1);
        Node* twoHead = new Node(-1);
        Node* zero = zeroHead;
        Node* one = oneHead;
        Node* two = twoHead;
        Node* temp = head;
        while(temp){
            if(temp -> data == 0){
                zero -> next = temp;
                zero = temp;
            }else if(temp -> data == 1){
                one -> next = temp;
                one = temp;
            }else{
                two -> next = temp;
                two = temp;
            }
            temp = temp -> next;
        }
        zero -> next = oneHead -> next ? oneHead -> next : twoHead -> next;
        one -> next = twoHead -> next;
        two -> next = NULL;
        delete zeroHead;
        delete oneHead;
        delete twoHead; 
        return zeroHead -> next;
    }
};

time is n
space is 1.
-------------------------------------------------------------------------------------------









