and , or, xor

xor --> even 1 xor become --> 0
        odd 1 xor become --> 1

~ flip the bits

>> (10 >> 2) --> (1010) --> (0010)

means devision by 2 twice (by right shift by 2)

<< (5 << 2) --> (00000000....101) --> (00000....10100)

means multiply by 2 twice (by left shift by 2)

------------------------------------------------------------------------

xor property is 

any same two elemment xor == 0

swap property --> swap two number by xor

a = a xor b, b = a xor b, a = a xor b 

------------------------------------------------------------------------

one element appear twice ok so, take all arr xor and xor is answer

-------------------------------------------------------------------------

xor of 1 ---> N

n % 4 == 0 --> print(n)

n % 4 == 1 --> print(1)

n % 4 == 2 --> print(n + 1)

n % 4 == 3 --> print(0) 

------------------------------------------------------------------------

now given range L --> R

take xor to 1 ---> R

take xor 1 --> L - 1

take this two xor

-----------------------------------------------------------------------

n & 1 == 1 --> odd else even

----------------------------------------------------------------------

given (N, i) check in N ith bit is set of not

1st way (N >> i) & 1

2nd way (1 << i) & N

(set or not)

---------------------------------------------------------------------

set the bit

(1 << i) | N

------------------------------------------------------------------

remove the bit

~(1 << i) & N

------------------------------------------------------------------

remove the last set bit

n & (n - 1)

---------------------------------------------------------------------

check N is power of 2 or not

n & (n -1) == 0 then N is power of 2

--------------------------------------------------------------------

count the number of set bit

n & (n - 1) != 0  --> cnt++;

---------------------------------------------------------------------

two element are apper 1 time and other are 2 time

class Solution {
public:
    vector<int> singleNumber(vector<int>& arr) {
        
        int n = arr.size();
        int all = 0;
        for(int i = 0; i < n; i++){
            all ^= arr[i];
        }
        int cnt = 0;
        while(all){
            if(all & 1){
                break;
            }
            cnt++;
            all >>= 1;
        }
        int a = 0, b = 0;
        for(int i = 0; i < n; i++){
            if(arr[i] & (1 << cnt)){
                a ^= arr[i];
            }else{
                b ^= arr[i];
            }
        }
        return {a, b};
    }
};

-------------------------------------------------------------------------------------

power set algorithms

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);    
    ll T = 1;
    // cin >> T;
    while(T--){
        int n; cin >> n;
        vector<int> v(n);
        int sum = 0;
        for(int i = 0; i < n; i++){
            int a; cin >> a;
            v[i] = a;
            sum += v[i];
        }
        for(int i = 0; i < (1 << n); i++){
            int a = 0;
            for(int j = 0; j < n; j++){
                if(i & (1 << j)){
                    a += v[j];
                }else{
                    a -= v[j];
                }
            }
            // cout << a << " " << b << endl;
            if(a % 360 == 0){
                cy; goto sahil;
            }
        }
        cn;
        sahil:; 
    }
    return 0;
}

-------------------------------------------------------------------------------

implement set using bitmasking

N --> 0 to 64;

0000000000000000000000000000...000000000000000000000

add --> if(n == 5) set bit 5 = 1; (x | (1 << i))

00000000000000000000000000...000000000000000010000

remove --> reset(bit 5)  (x & ~(1 << i))

print whateven is 1 just print

-----------------------------------------------------------------------------

xor of all subset

always be zero because event element occurs 2 ^ (N - 1) time and even so
